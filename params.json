{"body":"## Synopsis\r\n\r\nThis is an attempt to create an example boilerplate for modular web application development.  There have been a number\r\nof these created by various developers, but the intent of this one is to focus specifically on the structure of the \r\ncode necessary to create a consumable AMD-based library, rather than to provide all of the tools that are normally\r\nused in a new web application (build tools, test framework, etc).\r\n\r\n## Goals\r\nThe goals of this experiment is to show how to do the following:\r\n* Build a core javascript library that uses [RequireJS][1] for its dependency management\r\n* Ensure that this library is also AMD-compliant (meaning it is consumable by other AMD-based libraries).\r\n* Ensure that none of your module dependencies leak out into the global namespace.\r\n\r\n## Motivation\r\n\r\nIn the process of trying to build a modular and reusable component library, I understandably came to the conclusion \r\nthat I would want to use an [AMD][2] script loader.  I chose [RequireJS][1] to handle that.  However, I quickly \r\nfound myself fighting with understanding how to properly and efficiently meet the goals stated above in the goals \r\nsection. This made me feel like it was necessary to create the proper boilerplate so that I can concentrate on library\r\nfunctionality, rather than library code structure.\r\n\r\nAs a result, I have created this example project as a reference for myself for how to accomplish this. \r\n\r\n[1]: http://requirejs.org/\r\n[2]: https://github.com/amdjs/amdjs-api/wiki/AMD\r\n","name":"amd-library-boilerplate","google":"","tagline":"","note":"Don't delete this file! It's used internally to help with page regeneration."}